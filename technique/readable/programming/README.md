# プログラミング
## OOP（オブジェクト指向プログラミング）
以下の要素を持つ。
* 抽象化
* カプセル化
* 継承
* ポリモーフィズム

## DDD（ドメイン駆動設計）
### ドメイン
プログラムを適用する対象となる領域のこと。  
ソフトウェア開発を行うということは、直面している問題があるということ。直面している問題を解決するには、ドメインに向き合う必要がある。

### ドメインモデル
ドメインの概念をモデリングして、作られたモデルのこと。  
モデルとは、現実の事象や概念を抽象化した知識のことである。抽象化する作業をモデリングと呼ぶ。  
ドメインモデルは抽象化した知識であるため、問題を解決する力を持っていない。

### ドメインオブジェクト
ドメインモデルを、動作するモジュールとして表現したもの。  
ドメインオブジェクトになることで、問題を解決する力を持つ。  
レイヤードアーキテクチャのドメイン層に実装する。

### Value Object（値オブジェクト）
ドメインオブジェクトの一種であり、以下の特徴を持つ。
* 一意性を持たない
* 等価性によって比較される
* 不変である
* 交換が可能である

### Entity
ドメインオブジェクトの一種であり、以下の特徴を持つ。
* 一意性を持つ
* 同一性によって比較される
* 可変である
* ライフサイクルがある

### Domain Service
ドメインオブジェクトに実装すると、不自然になるふるまいを実装するオブジェクトのこと。  
「不自然になるふるまい」は、ドメインオブジェクトを横断する操作に多く見られる。  
ドメインサービスはドメインオブジェクトと異なり、自身のふるまいを変更するインスタンス特有の状態を持たない。  
レイヤードアーキテクチャのドメイン層に実装する。

### ドメインモデル貧血症
ドメインオブジェクトに記述されるべき知識やふるまいが、ドメインサービスやアプリケーションサービスに記述されている状態のこと。  
ドメインモデル貧血症が起きると、オブジェクト指向プログラミングから離れ、手続き型プログラミングを助長する状態となる。

### Repository
ドメインオブジェクトの永続化や再構築を行う。  
レイヤードアーキテクチャのドメイン層にインターフェース、インフラストラクチャ層に実装を置く。

### アプリケーションサービス
ユースケースを実現するオブジェクトのこと。  
ドメインに関する知識はここに書かず、ドメインオブジェクトやドメインサービスに書く。  
アプリケーションサービスは、自身の振る舞いを変更するインスタンス特有の状態を持たない。  
レイヤードアーキテクチャのアプリケーション層に実装する。

### ファクトリ
オブジェクトの生成処理を担当するオブジェクトやメソッドのこと。  
レイヤードアーキテクチャのドメイン層に実装する。  
本来にコンストラクタの仕事だが、複雑な処理になる場合はそれ専用のオブジェクトにするのが好ましい。  
ファクトリを使う動機付けとして以下を挙げられる
* オブジェクトの生成処理内で、データベースにアクセスしたい
* オブジェクトの生成処理内で、他のオブジェクトを生成する必要がある

### 集約
集約は関連するオブジェクトを囲う境界で定義される。  
外部から集約に対する操作は全て集約ルートを経由する。  
集約ルートとは集約に含まれる特定のオブジェクトのこと。  
集約の境界は「変更の単位」で区切るのがメジャー。  
また、リポジトリは集約単位で用意する。  

#### 通知オブジェクト
集約を実現することは不必要に内部データを公開しないことにつながる。  
ただし、getterのないドメインオブジェクトは永続化が困難になる。  
内部データを隠したまま、リポジトリに内部データを伝えるのが通知オブジェクトの役割。  
まず、ドメインオブエジェクトは通知オブジェクトのインターフェースに内部データを通知する。  
内部データの通知を受けた通知オブジェクトが永続化に必要なDTOを生成する。  
レイヤードアーキテクチャのドメイン層にインターフェース、インフラストラクチャ層に実装を置く。

### 仕様
仕様はあるオブジェクトが評価基準に達しているかを判定するオブジェクトのこと。  
オブジェクトの評価をオブジェクト自身にさせることは常に正しいとは限らない。  
レイヤードアーキテクチャのドメイン層に実装する。

## DI（依存性の注入）
関心の分離を行い、疎結合なプログラムの実現を目的にしている

## レイヤードアーキテクチャー
依存性逆転の原則を適用したバージョン。  
プレゼンテーション層はアプリケーション層、アプリケーション層はドメイン層のように、1つ下の層の呼び出しのみ許可されている。

```mermaid
graph LR
    ui[プレゼンテーション層]
    app[アプリケーション層]
    domain[ドメイン層]
    infra[インフラストラクチャ層]

    ui -->|依存| app
    app -->|依存| domain

    infra -.->|実装| app & domain
```

### プレゼンテーション層
入力チェックも含めた、入出力を実現する。  
アプリケーション層のユースケースの呼び出しをする。  
HTTPセッションを直接操作していいのはこの層のみ。  

### アプリケーション層
ロジック（分岐や計算）を持たず、ユースケースと認証・認可を実現する。  
ドメイン層のビジネスロジックの呼び出しをする。  
また、データベースのトランザクションの管理もこの層の責務である。

### ドメイン層
ビジネスロジックを実現する。  
永続化や再構築に依存してしまうため、ドメイン層でDDDのリポジトリを扱うのは好ましくない。

### インフラストラクチャ層
アプリケーション層やドメイン層のインターフェースの実装する。  
外部サービスへのアクセスの実装などがされる。  
データベースのトランザクションを管理することがあるが、あくまで補助的。アプリケーション層でユースケースごとにトランザクションを管理する必要がある。

## CQRS（コマンドクエリ責務分離）
Command Query Responsibility Segregationの略。  
コマンドは永続化のことであり、クエリは参照のことである。  
レイヤードアーキテクチャと組み合わせることがある。

## SOLID原則
### 単一責任の原則
Single Responsibility。  
クラスが持つ責任を1つにすること。

### オープン・クローズドの原則
クラスを拡張にはオープンにし、変更にはクローズドにすること。

### リスコフの置換原則
Liskov Substitution。  
親子関係のクラスがあるとき、プログラム上の親クラスのオブジェクトをすべて子クラスのオブジェクトに置き換えても、プログラムの特性が変わらないようにすること。

### インターフェイス分離の原則
Interface Segregation。  
不要なインターフェースの仕様を避けること。  
実装する必要がないメソッドがインターフェイスに定義されている場合は、インターフェースを適切に分割すること。

### DIP（依存性逆転の原則）
上位レベルのモジュールが下位レベルのモジュールに依存せず、どちらも抽象に依存していること。  
抽象は、実装の詳細に依存せず、実装の詳細が抽象に依存すること。  
  
身近なもので考えると理解しやすい。パソコンとキーボードを例にする。  
DIPを適用していない状態は、パソコンが特定のキーボードに依存している状態である。  
このとき、パソコンを買い替えると、古いキーボードの利用ができなくなる可能性がある。  
DIPを適用している状態は、パソコンとキーボードがUSBなどの規格に依存している状態である。  

#### 上位レベルのモジュールが下位レベルのモジュールに依存している状態
下位レベルのモジュールの変更が、上位レベルのモジュールに影響を与えることになる。  
```mermaid
graph LR
    top[class Top]
    bottom[class Bottom]

    top -->|依存| bottom
```

#### 依存性逆転の原則を適用した状態
下位レベルのモジュールに変更があっても、上位レベルのモジュールへの影響はない。
```mermaid
graph LR
    top[class Top]
    bottomimpl[class BottomImpl]
    bottom[interface Bottom]

    top -->|依存| bottom
    bottomimpl -.->|実装| bottom
```

## DRY原則
Don’t Repeat Yourselfの略。  
開発において情報を重複させないこと。

## YAGNI原則
余計な機能を実装せず、必要になってから実装すること。

## ビジネス例外とシステム例外
ビジネス例外とは業務ロジック上で想定される例外のこと。  
アプリケーションの正常な制御フローとして扱われる。  
システム例外とはアプリケーションの正常動作が困難になる例外のこと。  
ネットワーク障害やデータベース接続エラーが該当する。  
Javaの場合、ビジネス例外はRuntimeException、システム例外はExceptionを継承することが多い。

## 尋ねるな、命じよ
オブジェクトからデータを取り出し手続き的に処理を組み立てるのではなく、オブジェクトに処理を命じること。

## 品詞
メソッド名、変数名などは品詞に注意して名付ける。

## 変数名
否定形は使わない

## TODOコメント
```
// TODO: ここにコメント
```